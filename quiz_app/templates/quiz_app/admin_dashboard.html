<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Dashboard für {{ session.session_code }}</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background-color: #f4f7f6; }
        .container { background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1, h2 { color: #333; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #e2e6ea; }
        .correct { color: green; font-weight: bold; }
        .incorrect { color: red; font-weight: bold; }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover { background-color: #0056b3; }
    </style>
</head>


<body>
    <div class="container">
        <h1>Admin Dashboard für Session: {{ session.join_code }}</h1>

		<h2>Teilnehmer & Punkte</h2>
			<table>
				<thead>
					<tr>
						<th>Teilnehmer</th>
						<th>Punkte</th>
						<th>aktuelle Antwort</th>
					</tr>
				</thead>
				<tbody>
					{% for participant in participants %}
					<tr id="answer-{{ answer.id }}">
						<td>{{ participant.name }}</td>
						<td class="points" id="points-{{ answer.id }}">
							<button onclick="updateScore({{ participant.points }}, -1)">-1</button>
							<span class="score-value">{{ participant.points }}</span>
							<button onclick="updateScore({{ participants.points }}, +1)">+1</button>
						</td>
						<td>{{ participantanswer.chosen_answer }}</td>
					</tr>
					{% endfor %}
				</tbody>
			</table>


		<h1> Aktuelle Frage </h1>
			{% if current_question %}
	<p><strong>Frage:</strong> {{ current_question.text }}</p>
		<p><strong>Antwort:</strong> {{ current_question.correct_answer }}</p>
		{% else %}
		<p>Aktuell keine Frage in dieser Session.</p>
		{% endif %}

		<!--
		<h2 id="question-category">1) Kategorie auswählen</h2>
        <select id="category-selector" style="padding: 8px; margin-right: 10px;">
            <option value="">Kategorie auswählen...</option>
            {% for category in categories %}
				<option value="{{ category.id }}">{{ category.name }}</option>
			{% endfor %}
        </select>
		-->

		<h1> Nächste Frage </h1>
		<!--<h2 id="question-text">2) Frage auswählen</h2>-->
        <select id="question-selector" style="padding: 8px; margin-right: 10px;">
            <option value="">Frage auswählen...</option>
            {% for question in questions %}
                <option value="{{ question.id }}">{{ question.question_text }}</option>
            {% endfor %}
        </select>
		<span id="q-correct">{% if session.current_question %}{{ session.current_question.correct_answer }}{% endif %}</span>
        
		<button id="send-question-button">Frage senden</button>
        <p id="send-status-message" style="margin-top: 10px;"></p>
    </div>

    <script>
		/*

		NOTE: big garbage can (these were several tries to trigger communication between admin dashboard and participants)

        const sessionCode = "{{ session.session_code }}";
		const sessCode = "{{ session.session_code }}";
        const questionSelector = document.getElementById('question-selector');
		const categorySelector = document.getElementById('category-selector');
        const sendQuestionButton = document.getElementById('send-question-button');
        const sendStatusMessage = document.getElementById('send-status-message');
        const answersTableBody = document.querySelector('#answers-table tbody');
        const currentQuestionDisplay = document.getElementById('current-question-display');
		const sess = document.body.dataset.sessionCode;
		const catSel = document.getElementById("cat");
		const qSel   = document.getElementById("question");
		const send   = document.getElementById("send");
		const csrf   = "{{ csrf_token }}";   // wenn du JS inline einbettest
		const tbody  = document.getElementById("answer-body");
		const answerBody = document.getElementById("answer-body");

		function fetchCurrentQuestion(){
			fetch(`/api/current-question/${sessCode}/`)
				.then(r=>r.json())
				.then(d=>{
					if(d.id){
						document.getElementById("question-category").textContent =
							"Kategorie: " + d.category;
						document.getElementById("question-text").textContent = d.text;
				}
			});
		}
		setInterval(fetchCurrentQuestion, 3000);
		fetchCurrentQuestion();


        sendQuestionButton.onclick = function() {
			const sendQuestionUrl = "{% url 'send_question' %}";
            const selectedQuestionId = questionSelector.value;
            if (selectedQuestionId) {
                fetch(sendQuestionUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': '{{ csrf_token }}' // Django CSRF-Token einbinden
                    },
                    body: JSON.stringify({
                        session_code: sessionCode,
                        question_id: selectedQuestionId
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        sendStatusMessage.textContent = 'Frage erfolgreich gesendet!';
                        sendStatusMessage.style.color = 'green';
                        // Optional: Lade die Seite neu oder update die UI, um die neue Frage anzuzeigen
                        // Im echten Szenario würde man hier auch Channels für Live-Updates nutzen
                        currentQuestionDisplay.textContent = questionSelector.options[questionSelector.selectedIndex].text;
                        answersTableBody.innerHTML = '<tr><td colspan="4">Warten auf neue Antworten...</td></tr>'; // Tabelle leeren
                    } else {
                        sendStatusMessage.textContent = 'Fehler beim Senden der Frage: ' + data.message;
                        sendStatusMessage.style.color = 'red';
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    sendStatusMessage.textContent = 'Netzwerkfehler beim Senden der Frage.';
                    sendStatusMessage.style.color = 'red';
                });
            } else {
                sendStatusMessage.textContent = 'Bitte wähle eine Frage aus.';
                sendStatusMessage.style.color = 'orange';
            }
        };

		categorySelector.onchange = function () {
			const categoryId = categorySelector.value;

			if (categoryId) {
				fetch(`/get-questions-for-category/${categoryId}/`)
					.then(response => response.json())
					.then(data => {
						const questions = data.questions;

						// Bestehende Optionen im Frage-Selector löschen
						questionSelector.innerHTML = '<option value="">Frage auswählen...</option>';

						// Neue Fragen hinzufügen
						questions.forEach(q => {
							const option = document.createElement('option');
							option.value = q.id;
							option.textContent = q.text;
							questionSelector.appendChild(option);
						});
					})
					.catch(error => {
						console.error("Fehler beim Laden der Fragen für die Kategorie:", error);
					});
			} else {
				// Wenn keine Kategorie ausgewählt ist, Option zurücksetzen
				questionSelector.innerHTML = '<option value="">Frage auswählen...</option>';
			}
		};

		function updateScore(answerId, delta) {
			fetch("{% url 'update_answer_points' %}", {
				method: "POST",
				headers: {
					"Content-Type": "application/json",
					"X-CSRFToken": "{{ csrf_token }}"
				},
				body: JSON.stringify({
					answer_id: answerId,
					delta: delta
				})
			})
			.then(response => response.json())
			.then(data => {
				if (data.status === "success") {
					const pointsElement = document.querySelector(`#points-${answerId} .score-value`);
					pointsElement.textContent = data.new_points;
				} else {
					alert("Fehler: " + (data.message || "Unbekannter Fehler"));
				}
			})
			.catch(error => {
				console.error("Fehler beim Aktualisieren der Punkte:", error);
			});
		}


		function fetchScores() {
    		fetch('/api/scores/{{ session.id }}/')  // oder mit JS: `/api/scores/${sessionId}/`
        		.then(response => response.json())
        		.then(data => {
					const tbody = document.getElementById("score-table-body");
					tbody.innerHTML = "A"; // Tabelle leeren

					data.scores.forEach(participant => {
						const row = document.createElement("tr");
						row.innerHTML = `
							<td>${participant.name}</td>
							<td>${participant.points}</td>
						`;
						tbody.appendChild(row);
					});
				})
				.catch(err => {
					console.error("Fehler beim Abrufen der Punktzahlen:", err);
				});
		}

		// alle 5 Sekunden aktualisieren
		setInterval(fetchScores, 5000);

		// einmal sofort laden
		fetchScores();


		catSel.addEventListener("change", () => {
			const id = catSel.value;
			if (!id) return qSel.innerHTML = "<option>Frage…</option>";

			fetch(`/api/questions/${sess}/${id}/`)
				.then(r => r.json())
				.then(d => {
					qSel.innerHTML = '<option value="">Frage…</option>';
					d.questions.forEach(q => {
					qSel.insertAdjacentHTML("beforeend",
						`<option value="${q.id}">${q.text}</option>`);
					});
				});
			});
		
		/*
		send.addEventListener("click", () => {
			const qId = qSel.value;
			if (!qId) return alert("Bitte Frage wählen");

			fetch("/send-question/", {
				method: "POST",
				headers: {"Content-Type": "application/json", "X-CSRFToken": csrf},
				body: JSON.stringify({session_code: sess, question_id: qId})
			})
			.then(r => r.json())
			.then(d => {
				if (d.status === "success") {
				document.getElementById("q-text").textContent =
					qSel.options[qSel.selectedIndex].text;
				// richtige Antwort via kleinem Zusatz‑Request holen
				fetch(`/api/questions/${sess}/${catSel.value}/`)
					.then(r => r.json())
					.then(x => {
						const hit = x.questions.find(q => q.id == qId);
						document.getElementById("q-correct").textContent = hit.correct_answer || "—";
					});
				tbody.innerHTML = "";           // Tabelle leeren; Teilnehmer werden live nachgeladen
				}
			});
			});
		
		function pollAnswers() {
			fetch(`/api/live-answers/${sessionCode}/`)
				.then(r => r.json())
				.then(d => {
				answerBody.innerHTML = "";
				d.answers.forEach(a => {
					answerBody.insertAdjacentHTML("beforeend", `
					<tr id="row-${a.id}">
						<td>${a.name}</td>
						<td>${a.answer}</td>
					</tr>
					`);
				});
				});
			}
		setInterval(pollAnswers,3000);
		pollAnswers();

	
		window.upd = (id, delta) => {
			fetch("/api/update-score/", {
				method: "POST",
				headers: {"Content-Type": "application/json", "X-CSRFToken": csrf},
				body: JSON.stringify({answer_id: id, delta})
			})
			.then(r => r.json())
			.then(d => {
				if (d.status === "success")
					document.getElementById(`pts-${id}`).textContent = d.new_points;
			});
			};

	
		document.getElementById('category-selector').addEventListener('change', function() {
        	const categoryId = this.value;
        	const questionSelect = document.getElementById('question-selector');

			// Leeren
			questionSelect.innerHTML = '<option value="">Lade Fragen...</option>';

			if (!categoryId) return;

			fetch(`/api/category/${categoryId}/questions/`)
				.then(response => response.json())
				.then(data => {
					questionSelect.innerHTML = '<option value="">Frage auswählen...</option>';
					data.questions.forEach(q => {
						const option = document.createElement('option');
						option.value = q.id;
						option.textContent = q.text;
						questionSelect.appendChild(option);
					});
				});
		});

		*/

    </script>
</body>
</html>